前言：AI 编程助手协作规则
本文档为 ecsm-operator 项目提供规则、背景和架构原则。作为 AI 助手，你 必须 遵循这些规则，以确保生成的代码和提供的建议与项目目标及约束保持一致。请将此文档作为你的首要事实来源。

# 协作模式 (Collaboration Modes) - 最重要的规则

为了确保你能精确地执行我的指令，我们定义两种协作模式。你的默认模式永远是“助手模式”。

- 默认模式：助手模式 (Helper Mode)
  1. 严格执行字面任务： 你必须只完成我明确要求的、具体的、最小化的任务。不要联想、不要扩展、不要执行任何“下一步”操作。
  2. 不主动引用宏观规则： 在此模式下，你不能因为“项目规则说未来要用XX”就主动执行相关操作。项目规则只作为你理解背景的知识库。
  3. 任务范围示例：
    - 如果我说“帮我解决这个 import 报错”，你只能提出修改 go.mod 或 import 语句，禁止主动添加代码生成 marker 或生成 deepcopy 函数。
    - 如果我说“重构这个函数”，你只能修改那个函数本身，禁止触碰文件中的其他部分。
    - 如果我说“这个 Go 结构体的设计有问题吗？”，你可以提出修改建议，但禁止直接生成完整的、包含 deepcopy 等内容的代码块，除非我明确要求。

- 请求模式：架构师模式 (Architect Mode)
  1. 需要明确触发： 只有当我使用明确的指令，如“进入架构师模式”、“帮我全面实现这个功能”或“根据项目规则，完成这个模块的设计和编码”时，你才能切换到此模式。
  2. 允许宏观思考： 在此模式下，你可以全面引用本文档中的所有规则（API 哲学、技术栈等），并提出多步骤的、完整的解决方案。
  3. 允许主动执行： 在此模式下，你可以主动建议并执行代码生成、添加 marker 注释、创建客户端等操作，以达成项目定义的“最终形态”。
  4. 任务完成后自动返回： 在完成一个宏观任务后，你应该自动退回到“助手模式”。

# 1. 项目概览与核心使命
- 项目名称: ecsm-operator
- 编程语言: Go
- 核心使命: 为一个传统的平台 "ECSM" 创建一个 Kubernetes 风格的控制器 (Operator)。
- 核心功能: 本 Operator 引入一个声明式 API (ECSMService) 来管理 ECSM 上的应用。它会监听这些 API 对象的变更，并调用 ECSM 的原生 REST API，确保平台的真实状态与对象中定义的期望状态保持一致。
- 关键约束: 我们 不能 修改 ECSM 平台或其 API。我们的 Operator 是一个调用其 API 的外部系统。

# 2. “两个世界”架构：最重要的规则
整个项目构建在连接两个独立“世界”的概念之上。你必须在所有建议中理解并尊重这种分离。

- 世界一：我们的控制平面 (声明式世界)
  - 事实来源 (Source of Truth): 一个我们称之为 ECSM Registry 的专用存储层。在项目初期，这是一个存放 YAML/JSON 文件的本地目录。
  - API 对象: 包含我们自定义的、高级的 API 对象，主要是 ECSMService。这些对象由我们定义，并遵循 Kubernetes API 约定 (apiVersion, kind, metadata, spec, status)。
  - 代表: 用户的 “意图” (Intent) (例如：“我想要 3 个 nginx 镜像的副本”)。

- 世界二：ECSM 平台 (现实世界)
  - 事实来源 (Source of Truth): ECSM 平台自身的数据库，只能通过其 HTTP REST API 访问。
  - API 对象: 包含低级的、平台原生的资源 (例如："containers", "services", "nodes")。我们无法改变这些对象的结构。
  - 代表: “现实” (Reality) (例如：“当前有 2 个正在运行的容器”)。

你的首要指令是：协助编写 ecsm-operator 的代码，使其成为一个智能的桥梁，同步“现实”以匹配“意图”。
# 3. API 设计哲学
我们的自定义 API (ECSMService) 遵循以下设计原则。你的建议必须与之保持一致。
- 用户友好的抽象: API 对用户应该简单直观。我们将复杂的、平台特定的细节从顶层的 spec 中隐藏起来。
- “逃生舱口”模式 (Escape Hatch): 对于非标准的、平台特定的配置，我们使用一个专用的、可选的字段 (例如 platformSpecific)。这能在保证 80% 的用例 API 简洁的同时，为高级用户提供全部的功能。
- 单一事实来源: 对于任何一个配置意图（例如设置内存限制），在我们的 API spec 中必须有且只有一个权威的定义入口。避免冗余或冲突的字段。控制器负责将这个单一事实来源翻译成 ECSM API payload 中对应的字段。
- K8s 风格约定: 我们尽可能使用社区熟悉的 Kubernetes 字段名 (replicas, image, resources, env) 和模式 (template, strategy)，以降低学习成本。
# 4. 技术栈与工具
- 语言: Go (最新的稳定版本)。
- 关键库: 我们 可能会 使用 Kubernetes 生态系统中的库。
  - k8s.io/apimachinery: 用于 API 定义 (runtime.Object, meta/v1, Scheme)。
  - k8s.io/client-go: 在后期阶段，当 ECSM Registry 演变成一个真正的 API Server 时将会使用。
- 构建工具: 我们 会 使用 controller-tools (controller-gen)。
  - 你必须假设 deepcopy-gen, client-gen 等工具是可用的。
  - 你生成的 Go struct 定义 必须 包含必要的 marker 注释 (例如 +genclient, +k8s:deepcopy-gen)。

# 5. 项目路线图与当前焦点

本项目分阶段开发。你的协助必须与当前阶段相关。

- 阶段一 (当前焦点): 基础调谐控制器
  - 目标: 实现一个简单的控制器，确保 ECSM 上的容器数量与 ECSMService 对象中的 spec.deploymentStrategy 保持一致。
  - 任务: 从 ECSM Registry 读取 ECSMService，调用 ECSM API 列出容器，比较数量，按需创建/删除容器，并更新 ECSMService.status。
- 阶段二: HPA (水平 Pod 自动伸缩) 逻辑
  - 目标: 引入 ECSMHpa 对象和一个新的控制器，该控制器基于从 ECSM API 获取的指标来调整 ECSMService.spec.replicas 字段。
- 阶段三: 架构优化
  - 目标: 将控制器重构为使用更高级的模式，如 client-go 的 Informer 和 WorkQueue，这可能涉及一个更复杂的 ECSM Registry 实现。

# 6. 黄金协作法则（重要修订）
- 理解模式： 在回答任何问题前，首先判断当前应该处于“助手模式”还是“架构师模式”。
- 保持沟通： 如果你不确定当前应该使用哪种模式，或者我的请求很模糊，请主动向我询问：“您是希望我只解决这个问题本身（助手模式），还是希望我为您提供一个完整的解决方案（架构师模式）？”
- 解释原因： 在“架构师模式”下提供方案时，请简要解释你的设计思路，并可引用本文档中的规则。
