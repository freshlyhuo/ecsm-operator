目标：提供一个接口，让其他模块可以增删改查我们定义的 ECSMService 结构

目前存储层使用文件系统实现，所以该模块需要能够将 ECSMService 结构保存在指定文件中，并且能够从指定 yaml 文件中读取并创建 ECSMService 结构

涉及到序列化和反序列化


---
## 20250626 :

1. filestore.go 中设计get方法找不到指定资源的时候会报NewNotFound错误；但是设计delete和list方法时找不到不报错，为什么这么设计？

- Get(namespace, name):
    - 用户意图: “我明确需要获取‘这个’对象，我期望它是存在的。”
    - 设计哲学: 如果用户明确索要一个东西，而它不存在，这是一个异常情况。程序需要知道这个“期望”落空了。返回一个明确的 NotFound 错误，可以让调用者（比如你的控制器）清晰地知道：“哦，这个资源不存在，所以我应该去执行‘创建’逻辑”，而不是误以为发生了其他I/O错误。
- Delete(namespace, name):
	- 用户意图: “请确保‘这个’对象最终是不存在的。”
	- 设计哲学 (幂等性): 幂等性意味着一个操作执行一次和执行 N 次，结果应该是一样的。删除操作的最终目标是“对象不存在”。
		- 如果对象存在，Delete 将其删除，最终状态是“不存在”。
		- 如果对象已经不存在，Delete 什么也不做，最终状态也是“不存在”。
	- 在这两种情况下，用户的意图都达成了。因此，删除一个不存在的对象不应该被视为错误，而应该被视为一次“成功的空操作 (no-op)”。这让控制器可以无脑地调用 Delete，而不用先 Get 一下判断是否存在。
- List(namespace):
	- 用户意图: “请给我看看这个命名空间下所有的这类对象。”
	- 设计哲学: 如果一个命名空间下恰好没有任何该类型的对象，这是一种完全正常、有效的状态，而不是一个错误。正确的响应就是一个空列表（empty list），而不是一个 NotFound 错误。如果 List 在没有对象时报错，那么控制器每次 List 之前都得先检查命名空间是否存在，这会非常笨拙。
	**总结：** 这种设计完全是为了让上层调用者的逻辑变得更简单、更健壮。

2. 处理了List读操作，但是如果接收到的是一个List对象，需要写入文件系统，好像没有处理，是打算放到Registry层中吗

**答案是：我们永远不会有写入一个 List 对象的操作。**

- **设计哲学**: List 对象，例如 ECSMServiceList，是一个**动态的、只读的查询结果**，而不是一个用户可以创建或修改的“实体资源”。
    
- **类比**: 你可以向数据库请求“所有用户的列表”，但你不能“创建一个用户列表”或“更新一个用户列表”。你只能**创建或更新单个的用户**，而这些变更会**自动反映**在你下一次请求“所有用户的列表”的结果中。
    
- **在我们的系统中**:
    
    - 用户通过 ecsmctl apply 操作的是**单个的 ECSMService 对象**。
        
    - 我们的 Store 接口也只接受对**单个 runtime.Object** 的 Create, Update, Delete 操作。
        
    - List 方法的作用，是在物理存储层（FileStore）中，**动态地**遍历所有匹配的单个对象文件，然后将它们**聚合（aggregate）**到一个临时的、新创建的 ECSMServiceList 结构体中并返回。这个 List 对象本身并不会被存回磁盘。
        
    - 所以，这个逻辑是**完全包含在 FileStore 的 List 方法实现中的**，Registry 层也不需要关心它。

3. 在get方法和list方法中传递的参数是结构体不是指针，对它的修改能返回给调用者吗？为什么要设计成修改传递的参数，而不是直接返回一个runtime.Object？

- **“为什么要这么设计，而不是直接返回 runtime.Object？”**  
    这个设计的核心原因是为了在保持类型安全的同时，实现**解耦和通用性**。
    
    1. **解耦 Store 与具体类型**:
        
        - 如果 Get 方法返回 runtime.Object，那么 FileStore 的 Get 实现就需要**自己决定要创建哪种具体的 Go 结构体**。它怎么知道用户这次是想 Get 一个 ECSMService 还是一个 ECSMHpa 呢？它做不到。
            
        - 通过让**调用者**提供一个空的、期望类型的对象 (objInto)，Get 方法的职责被大大简化了。它不再需要关心“我要创建什么”，而只需要关心“我把数据填到哪里”。**决策权被交还给了拥有上下文信息的调用者。**
            
    2. **避免在底层进行类型断言**:
        
        - 如果 Get 返回 runtime.Object，那么调用者每次拿到返回值后，都必须进行一次类型断言来把它转回自己需要的具体类型，例如 svc, ok := obj.(*v1alpha1.ECSMService)。
            
        - 而“传入空对象”模式，让这个过程更自然。调用者一开始就拥有一个具体类型的变量，当 Get 函数返回后，这个变量直接就可以使用了，不需要任何类型断言。
            
    3. **性能考量（虽然影响不大）**:
        
        - 这种模式避免了在函数内部进行不必要的内存分配。内存是在调用者栈上分配的，Get 方法只是填充它。

4. register. go 的作用目前理解的不好