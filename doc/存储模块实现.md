目标：提供一个接口，让其他模块可以增删改查我们定义的 ECSMService 结构

目前存储层使用文件系统实现，所以该模块需要能够将 ECSMService 结构保存在指定文件中，并且能够从指定 yaml 文件中读取并创建 ECSMService 结构

涉及到序列化和反序列化


---
## 20250626 

1. filestore.go 中设计get方法找不到指定资源的时候会报NewNotFound错误；但是设计delete和list方法时找不到不报错，为什么这么设计？

- Get(namespace, name):
    - 用户意图: “我明确需要获取‘这个’对象，我期望它是存在的。”
    - 设计哲学: 如果用户明确索要一个东西，而它不存在，这是一个异常情况。程序需要知道这个“期望”落空了。返回一个明确的 NotFound 错误，可以让调用者（比如你的控制器）清晰地知道：“哦，这个资源不存在，所以我应该去执行‘创建’逻辑”，而不是误以为发生了其他I/O错误。
- Delete(namespace, name):
	- 用户意图: “请确保‘这个’对象最终是不存在的。”
	- 设计哲学 (幂等性): 幂等性意味着一个操作执行一次和执行 N 次，结果应该是一样的。删除操作的最终目标是“对象不存在”。
		- 如果对象存在，Delete 将其删除，最终状态是“不存在”。
		- 如果对象已经不存在，Delete 什么也不做，最终状态也是“不存在”。
	- 在这两种情况下，用户的意图都达成了。因此，删除一个不存在的对象不应该被视为错误，而应该被视为一次“成功的空操作 (no-op)”。这让控制器可以无脑地调用 Delete，而不用先 Get 一下判断是否存在。
- List(namespace):
	- 用户意图: “请给我看看这个命名空间下所有的这类对象。”
	- 设计哲学: 如果一个命名空间下恰好没有任何该类型的对象，这是一种完全正常、有效的状态，而不是一个错误。正确的响应就是一个空列表（empty list），而不是一个 NotFound 错误。如果 List 在没有对象时报错，那么控制器每次 List 之前都得先检查命名空间是否存在，这会非常笨拙。
	**总结：** 这种设计完全是为了让上层调用者的逻辑变得更简单、更健壮。

2. 处理了List读操作，但是如果接收到的是一个List对象，需要写入文件系统，好像没有处理，是打算放到Registry层中吗

**答案是：我们永远不会有写入一个 List 对象的操作。**

- **设计哲学**: List 对象，例如 ECSMServiceList，是一个**动态的、只读的查询结果**，而不是一个用户可以创建或修改的“实体资源”。
    
- **类比**: 你可以向数据库请求“所有用户的列表”，但你不能“创建一个用户列表”或“更新一个用户列表”。你只能**创建或更新单个的用户**，而这些变更会**自动反映**在你下一次请求“所有用户的列表”的结果中。
    
- **在我们的系统中**:
    
    - 用户通过 ecsmctl apply 操作的是**单个的 ECSMService 对象**。
        
    - 我们的 Store 接口也只接受对**单个 runtime.Object** 的 Create, Update, Delete 操作。
        
    - List 方法的作用，是在物理存储层（FileStore）中，**动态地**遍历所有匹配的单个对象文件，然后将它们**聚合（aggregate）**到一个临时的、新创建的 ECSMServiceList 结构体中并返回。这个 List 对象本身并不会被存回磁盘。
        
    - 所以，这个逻辑是**完全包含在 FileStore 的 List 方法实现中的**，Registry 层也不需要关心它。

3. 在get方法和list方法中传递的参数是结构体不是指针，对它的修改能返回给调用者吗？为什么要设计成修改传递的参数，而不是直接返回一个runtime.Object？

- **“为什么要这么设计，而不是直接返回 runtime.Object？”**  
    这个设计的核心原因是为了在保持类型安全的同时，实现**解耦和通用性**。
    
    1. **解耦 Store 与具体类型**:
        
        - 如果 Get 方法返回 runtime.Object，那么 FileStore 的 Get 实现就需要**自己决定要创建哪种具体的 Go 结构体**。它怎么知道用户这次是想 Get 一个 ECSMService 还是一个 ECSMHpa 呢？它做不到。
            
        - 通过让**调用者**提供一个空的、期望类型的对象 (objInto)，Get 方法的职责被大大简化了。它不再需要关心“我要创建什么”，而只需要关心“我把数据填到哪里”。**决策权被交还给了拥有上下文信息的调用者。**
            
    2. **避免在底层进行类型断言**:
        
        - 如果 Get 返回 runtime.Object，那么调用者每次拿到返回值后，都必须进行一次类型断言来把它转回自己需要的具体类型，例如 svc, ok := obj.(*v1alpha1.ECSMService)。
            
        - 而“传入空对象”模式，让这个过程更自然。调用者一开始就拥有一个具体类型的变量，当 Get 函数返回后，这个变量直接就可以使用了，不需要任何类型断言。
            
    3. **性能考量（虽然影响不大）**:
        
        - 这种模式避免了在函数内部进行不必要的内存分配。内存是在调用者栈上分配的，Get 方法只是填充它。

4. register. go 的作用目前理解的不好

## 20250627

要开始写 registry 模块，这里涉及一些业务逻辑的填充，数据流如下：

| 步骤  | 参与者       | 输入数据形态              | 输出数据形态              | 核心动作                   |
| --- | --------- | ------------------- | ------------------- | ---------------------- |
| 1   | ecsmctl   | []byte (YAML)       | *ecsmv1.ECSMService | **解码 (Decode)**        |
| 2   | ecsmctl   | *ecsmv1.ECSMService | (函数调用)              | **调用业务层**              |
| 3   | Registry  | *ecsmv1.ECSMService | *ecsmv1.ECSMService | **执行业务规则** (填充系统字段)    |
| 4   | FileStore | runtime.Object      | []byte (JSON)       | **序列化 (Encode)** 并写入磁盘 |
写之前还存在哪些疑点？

1. 目前知道了 kubrnetes 的 client 层有 restClient 和 clientSet 两种，那我们这个的 registry 要不要也分层设计呢？提供一个 ECSMService 专用的 Reg，但是实际上使用的都是底层共同的 reg
2. reg 里除了填充系统字段，在资源对象的增删改查过程中还承担哪些任务
3. 后续 ecsmctl 和其他控制器统一调用的就是 reg 了对吧

### 问题一

这个地方要处理的逻辑比较多，也想模仿 Client-go ，但是怎么和获取 ECSMAPI 的客户端区分开呢，这点现在比较乱，要仔细整理一下

#### 链式填充
RESTClient 的链式填充字段，什么时候需要填充（增删改查阶段中分别需要怎样的填充）；为什么需要链式填充，对我们这个项目来说有没有参考借鉴的价值

RESTClient 是一个**低级的、通用的 HTTP 客户端**。它的目标是能够构造出 Kubernetes API 所需的、任意复杂的 RESTful 请求。一个请求通常由多个部分组成：

- **HTTP 动词 (Verb)**: GET, POST, PUT, DELETE...
    
- **API 路径 (Path)**: /api/v1/namespaces/{namespace}/pods/{name}
    
- **URL 参数 (Parameters)**: ?labelSelector=app=nginx&timeoutSeconds=30
    
- **请求体 (Body)**: 一个序列化后的 JSON 对象。
    

RESTClient 的设计者没有选择创建一个包含几十个参数的巨大函数，而是采用了一种**链式调用**的方式，让调用者像“搭积木”一样，一步步地构建出一个完整的请求。

**为什么我们不需要？**  
因为我们的 Store 是一个**Go 接口**，而不是一个**HTTP 客户端**。我们的“增删改查”操作已经通过定义不同的方法（Create, Update, Get, List, Delete）来区分了，并且我们通过传递**类型安全**的 Go struct 来传递参数，而不是通过 URL 参数和 Body。

**真正的借鉴价值在于理解其分层思想，并应用到我们自己的架构中：**

1. **保持底层通用**: 我们的 Store 接口就像 RESTClient 一样，是通用的。它只关心 runtime.Object，不关心具体的业务。
    
2. **构建类型安全的上层**: 我们的 Registry 层，特别是我们之前讨论的 ECSMServiceInterface，就像 client-go 的 Typed Client。它为调用者提供了类型安全、意图明确的接口（Create(service *v1.ECSMService)）。
    
3. **将“构建”逻辑封装在上层**:
    
    - client-go 的 PodClient 负责调用一系列链式方法来构建一个 Request。
        
    - 我们的 Registry 层的 CreateService 方法，也负责“构建”一个完整的、带有 UID 和时间戳的 ECSMService 对象，然后再把它传递给底层的 Store。
        

**总结与实践：**

对我们当前的项目来说，我们应该：

- **欣赏并理解** RESTClient 的链式设计，但**不要**在我们的 Registry 或 Store 中模仿它。
    
- **坚持我们当前的分层架构**:
    
    - 一个通用的 Store 接口，处理 runtime.Object。
        
    - 一个类型安全的 Registry 业务逻辑层，为每种资源提供明确的 Get/Create/Update 等方法。
        
- **将“填充字段”的逻辑放在 Registry 层**：我们的 Registry 方法就是那个负责“搭积木”的地方，它在调用 Store 之前，确保了所有必要的字段（UID, 时间戳，默认值）都已经被正确地**填充**到了对象上。
#### 和 ECSM 通信客户端的区分
考虑到后续还要实现 ecsmclient，这个存储上的怎么和与 ecsmapi 通信的进行区分？二者又怎样统一协作？

- **Registry (和它的 Store)**: 服务于 **“声明式世界”**。
    
- **EcsmClient**: 服务于 **“现实世界”** 。

```
+------------------------------------------------------------------+
|                          ecsm-operator                           |
|                        (The "Brain")                             |
|                                                                  |
|   +----------------------------------------------------------+   |
|   |                  Controller's Reconciler                 |   |
|   |                   (The Core Logic)                       |   |
|   |                                                          |   |
|   |  1. "What do I WANT to have?"                            |   |
|   +--------------------------+-------------------------------+   |
|                              |                                   |
|  (Asks our "Librarian")      | (Asks our "Field Agent")          |
|                              v                                   |
|   +--------------------------+-------------------------------+   |
|   |                          |                               |   |
|   | +----------------------+ | +---------------------------+ |   |
|   | |                      | | |                           | |   |
|   | |   Registry Client    | | |      EcsmClient           | |   |
|   | | (Your Typed Client)  | | | (ECSM Platform API Client)| |   |
|   | |                      | | |                           | |   |
|   | +----------------------+ | +---------------------------+ |   |
|   |           |            |               |               |   |
|   +-----------|------------+---------------+---------------+   |
|               v                            v                   |
+---------------|----------------------------|-------------------+
                |                            |
+---------------|------------------+  +------|------------------------------------+
|   ECSM Registry (FileStore)      |  |             ECSM Platform              |
| (Stores ECSMService objects)     |  |         (The Real World)               |
|                                  |  |                                          |
|   "I know you want 3 replicas"   |  |   "I can create/list/delete containers"  |
+----------------------------------+  +------------------------------------------+
```

1. 如何区分？职责的清晰界定
	**一句话区分：Registry 读写的是我们的“蓝图”，EcsmClient 操作的是真实的“砖块和水泥”。**

2. 二者如何统一协作？
	它们从不直接对话。它们唯一的交集，就是在**控制器的调谐循环 (Reconcile 函数)** 中被同时使用。控制器是那个同时懂两种语言的“项目经理”。

### 问题二

1. **验证 (Validation)**:
    
    - 在将对象存入 Store 之前，Registry 负责进行业务层面的验证。
        
    - **示例**: DeploymentStrategy 的 Type 是 "Dynamic" 时，Replicas 字段**必须**被设置。如果用户没设置，Registry 的 CreateService 就应该返回一个验证错误，而不是让一个不完整的对象被存入 Store。Store 只管存储，不负责校验业务规则。
        
2. **默认值填充 (Defaulting)**:
    
    - Registry 负责为一个不完整的对象填充上合理的默认值。
        
    - **示例**: 如果用户创建 ECSMService 时没有指定 UpgradeStrategy，Registry 的 CreateService 方法应该自动为其设置一个默认的策略，比如 Type: "Never"。
        
3. **组合操作 (Composition)**:
    
    - Registry 可以提供更高级的、组合式的操作。
        
    - **示例**: 我们可以实现一个 ApplyService 方法。它的逻辑是：  
        a. 调用 store.Get 获取对象。  
        b. 如果返回 NotFound 错误，就执行 CreateService 的逻辑。  
        c. 如果对象存在，就执行 UpdateService 的逻辑。  
        这正是 kubectl apply 的核心逻辑。
        
4. **状态更新的特殊处理 (Status Updates)**:
    
    - 在 Kubernetes 中，更新一个对象的 status 子资源是一个独立的操作。Registry 层可以提供一个 UpdateStatus 方法。
        
    - 这个方法会先 Get 最新的对象，然后只用新的 status 覆盖旧的 status，而 spec 保持不变，最后调用 store.Update。这可以防止控制器在更新状态时意外地覆盖掉用户对 spec 的修改。

### 问题三

>  是的，可能你说的没问题，但是我心中还是觉得不对劲，可能是我认为我们的registry更应该承担一个单一职责（专注于声明世界spec）的组件，而非apiserver那样记录spec+status的完整唯一事实中心；因为即使把status写会磁盘，那也是不可信的呀，status的唯一事实来源应该是ecsm的server，而非我们的registry

你说的那句话，是整个问题的核心，也是我们必须彻底辨析清楚的：

> "status的唯一事实来源应该是ecsm的server，而非我们的registry"

这句话**对了一半，也错了一半**。让我们来拆解它。

对：status 字段里所有信息的**最终、原始、权威的来源**，绝对是 ECSM Server。我们的控制器通过 EcsmClient 从 ECSM Server 获取到“有2个容器正在运行”这个**原始事实**，这是计算 status 的**输入**。
错：**Status 字段的真正作用，不是为了记录“绝对的实时真相”，而是为了记录“控制器在最后一次同步时，所观察到的现实快照，以及它基于这个快照所采取的行动的总结”。**

它回答的不是“现在 ECSM 上究竟有什么？”，而是“**我（Operator）认为 ECSM 上有什么，并且我已经做了什么？**”

Status 就像控制器的**“工作日志”或“记忆”**。它让控制器在每次醒来时，都能回忆起“我上次干到哪了”。

在上面那个缩容场景中，如果 status 被持久化了：

1. **Reconcile #1 (成功)**:
    
    - ... (删除一个容器) ...
        
    - **更新 Status**: 控制器在最后一步，会调用 EcsmClient 再次 List，发现现在有 2 个容器了。然后它会把 status.replicas 更新为 2，并将其**写回 Registry**。
        
2. **Reconcile #2 (如果因为任何原因再次触发)**:
    
    - **读 Registry**: 控制器读取到 spec.replicas: 2 和 status.replicas: 2。
        
    - **决策**: “期望和我的记录是一致的，我大概率什么都不用做，但我还是去核实一下现实吧。”
        
    - **读 ECSM API**: 发现现实中确实是 2 个。
        
    - **最终结果**: 系统状态完全一致，控制器可以安心地等待下一次变更。

你认为 Registry 应该“专注于声明世界spec”，这个想法非常好，它促使我们对 Registry 的职责做出更精确的定义。

**Registry 的职责不是“唯一事实中心”，而是“我们系统的唯一期望与状态记录中心”。**

- **spec**: 是**用户**对系统的期望。
    
- **status**: 是**我们的 Operator** 对系统状态的**记录和总结**。
    

这两者共同构成了一个完整的 API 对象，缺一不可。ECSM Server 是**现实**，而 Registry 中的 ECSMService 对象（包含 spec 和 status）是我们为了管理这个现实而创建的、一个完整的**数字孪生模型**。

**我完全理解你“不对劲”的感觉，因为它确实触及了整个系统中最核心、最抽象的设计权衡。** 希望这个更深入的解释，能让你信服为什么持久化 status 不仅是出于性能考量，更是出于系统**正确性、健壮性和可恢复性**的根本需要。这是一个经过了像 Kubernetes 和其他大型分布式控制系统多年实践后，被证明是唯一可行的方案。

